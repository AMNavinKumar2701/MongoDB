

============================================================

# **MONGODB PROJECTION OPERATORS — INTERVIEW STYLE NOTES (.TXT)**

============================================================

============================================================

# **1) ARRAY FIELD PROJECTION & LIMITATIONS**

============================================================

---

## **THEORY (BULLET POINTS)**

* Projection controls which fields appear in result.
* Normal projection returns the **entire array**, unchanged.
* Cannot do `"items.qty": 1` directly — MongoDB does not partially extract arrays.
* Must use `$elemMatch`, `$slice`, `$` positional to extract element(s).
* Arrays always preserve original order.
* You can include or exclude arrays like any other field.
* `_id` can be excluded while including other fields.

---

## **PROPERTIES**

* Full array returned unless special operator used.
* Exclusion removes entire array from output.
* Cannot mix inclusion & exclusion (except `_id`).
* If array missing → null or not present in result.
* Projection cannot modify array content.

---

## **SYNTAX**

```
db.collection.find({ query }, { arrayField: 1, _id: 0 })
db.collection.find({ query }, { arrayField: 0 })
```

---

## **10 EXAMPLES WITH DESCRIPTIVE QUESTIONS**

1. **Q: Show only the items array for order 1**

```
db.orders.find({ _id: 1 }, { items: 1, _id: 0 });
```

2. **Q: Show only reviews for order 2**

```
db.orders.find({ _id: 2 }, { reviews: 1, _id: 0 });
```

3. **Q: Show items and reviews for John**

```
db.orders.find({ customer: "John" }, { items: 1, reviews: 1 });
```

4. **Q: Remove items array from output**

```
db.orders.find({ _id: 1 }, { items: 0 });
```

5. **Q: Exclude reviews for customer Mary**

```
db.orders.find({ customer: "Mary" }, { reviews: 0 });
```

6. **Q: Include statusLogs only**

```
db.orders.find({}, { statusLogs: 1 });
```

7. **Q: Show items only, hide _id**

```
db.orders.find({}, { items: 1, _id: 0 });
```

8. **Q: Show everything except statusLogs**

```
db.orders.find({ _id: 3 }, { statusLogs: 0 });
```

9. **Q: Show only items array for all orders**

```
db.orders.find({}, { items: 1, _id: 0 });
```

10. **Q: Include items, reviews, and statusLogs**

```
db.orders.find({}, { items: 1, reviews: 1, statusLogs: 1 });
```

============================================================

# **2) `$elemMatch` PROJECTION**

============================================================

---

## **THEORY (BULLET POINTS)**

* Used to return **only ONE array element** matching a condition.
* Filters inside projection, unlike normal array projection.
* Works **only** on arrays-of-documents.
* NOT the same as query `$elemMatch`.

---

## **PROPERTIES**

* Returns **first matched element** only.
* Does not return multiple matches.
* Cannot use `$or` inside projection `$elemMatch`.
* Cannot combine with `$slice` on same field.
* If no match → empty array.

---

## **SYNTAX**

```
db.collection.find(
  { query },
  { arrayField: { $elemMatch: { condition } }, _id: 0 }
)
```

---

## **10 EXAMPLES WITH QUESTIONS**

1. **Q: Show the item where price > 100 for order 1**

```
db.orders.find({ _id: 1 }, { items: { $elemMatch: { price: { $gt: 100 } } } });
```

2. **Q: Show the item whose product is "book"**

```
db.orders.find({ _id: 1 }, { items: { $elemMatch: { product: "book" } } });
```

3. **Q: Show the element where qty >= 10**

```
db.orders.find({ _id: 1 }, { items: { $elemMatch: { qty: { $gte: 10 } } } });
```

4. **Q: Show item where qty > 1 AND price > 100**

```
db.orders.find({ _id: 1 },
  { items: { $elemMatch: { qty: { $gt: 1 }, price: { $gt: 100 } } } });
```

5. **Q: Show first review with rating > 4**

```
db.orders.find({ _id: 2 },
  { reviews: { $elemMatch: { rating: { $gt: 4 } } } });
```

6. **Q: Show status entry equal to 'shipped'**

```
db.orders.find({ _id: 1 },
  { statusLogs: { $elemMatch: { status: "shipped" } } });
```

7. **Q: Show review where rating = 3**

```
db.orders.find({ _id: 3 },
  { reviews: { $elemMatch: { rating: 3 } } });
```

8. **Q: Show item with price between 10 and 100**

```
db.orders.find({ _id: 1 },
  { items: { $elemMatch: { price: { $gte: 10, $lte: 100 } } } });
```

9. **Q: Show item where qty <= 2**

```
db.orders.find({ _id: 2 },
  { items: { $elemMatch: { qty: { $lte: 2 } } } });
```

10. **Q: Show statusLog where status='delivered'**

```
db.orders.find({ _id: 1 },
  { statusLogs: { $elemMatch: { status: "delivered" } } });
```

============================================================

# **3) `$slice` PROJECTION**

============================================================

---

## **THEORY (BULLET POINTS)**

* Extracts a **subset** of array elements.
* Does NOT filter by condition.
* Used for first N, last N, or skip+limit.

---

## **PROPERTIES**

* `$slice: n` → first n items.
* `$slice: -n` → last n items.
* `$slice: [skip, limit]` → skip then limit.
* Cannot combine with `$elemMatch`.
* Order preserved.

---

## **SYNTAX**

```
db.collection.find({}, { arrayField: { $slice: n } })
db.collection.find({}, { arrayField: { $slice: -n } })
db.collection.find({}, { arrayField: { $slice: [skip, limit] } })
```

---

## **10 EXAMPLES WITH QUESTIONS**

1. **Q: Show first 2 items of order 1**

```
db.orders.find({ _id: 1 }, { items: { $slice: 2 } });
```

2. **Q: Show last 2 items of order 1**

```
db.orders.find({ _id: 1 }, { items: { $slice: -2 } });
```

3. **Q: Show first review**

```
db.orders.find({ _id: 1 }, { reviews: { $slice: 1 } });
```

4. **Q: Show last review**

```
db.orders.find({ _id: 1 }, { reviews: { $slice: -1 } });
```

5. **Q: Skip 1, show next 2 items**

```
db.orders.find({ _id: 1 }, { items: { $slice: [1, 2] } });
```

6. **Q: Show first statusLogs entry**

```
db.orders.find({ _id: 1 }, { statusLogs: { $slice: 1 } });
```

7. **Q: Show last 3 statuses**

```
db.orders.find({ _id: 1 }, { statusLogs: { $slice: -3 } });
```

8. **Q: Skip first review, show one**

```
db.orders.find({ _id: 1 }, { reviews: { $slice: [1, 1] } });
```

9. **Q: Show first 3 items of order 3**

```
db.orders.find({ _id: 3 }, { items: { $slice: 3 } });
```

10. **Q: Show last status of order 2**

```
db.orders.find({ _id: 2 }, { statusLogs: { $slice: -1 } });
```

============================================================

# **4) `$meta` PROJECTION**

============================================================

---

## **THEORY (BULLET POINTS)**

* Used with TEXT SEARCH to show **textScore**.
* Works only if a text index exists.
* Supports sorting by score.

---

## **PROPERTIES**

* Returns a double value.
* Only `"textScore"` allowed.
* Cannot apply directly to arrays.
* Requires `$text` in query.

---

## **SYNTAX**

```
db.collection.find(
  { $text: { $search: "term" } },
  { scoreField: { $meta: "textScore" } }
)
```

---

## **10 EXAMPLES WITH QUESTIONS**

(Assume)

```
db.orders.createIndex({ customer: "text", "reviews.comment": "text" });
```

1. **Q: Show text score for matching "Excellent"**

```
db.orders.find(
 { $text: { $search: "Excellent" } },
 { score: { $meta: "textScore" } }
);
```

2. **Q: Sort results by textScore**

```
db.orders.find(
 { $text: { $search: "Good" } },
 { s: { $meta: "textScore" } }
).sort({ s: { $meta: "textScore" } });
```

3. **Q: Search two words and show rank**

```
db.orders.find(
 { $text: { $search: "good average" } },
 { rank: { $meta: "textScore" } }
);
```

4. **Q: Return reviews + textScore**

```
db.orders.find(
 { $text: { $search: "excellent" } },
 { reviews: 1, score: { $meta: "textScore" } }
);
```

5. **Q: Search exact phrase "Excellent"**

```
db.orders.find(
 { $text: { $search: "\"Excellent\"" } },
 { score: { $meta: "textScore" } }
);
```

6. **Q: Search good but exclude 'bad'**

```
db.orders.find(
 { $text: { $search: "good -bad" } },
 { score: { $meta: "textScore" } }
);
```

7. **Q: Filter by ID + get textScore**

```
db.orders.find(
 { $text: { $search: "Excellent" }, _id: 1 },
 { score: { $meta: "textScore" } }
);
```

8. **Q: Search 'Loved' in comments**

```
db.orders.find(
 { $text: { $search: "Loved" } },
 { ms: { $meta: "textScore" } }
);
```

9. **Q: Sort by customer name then score**

```
db.orders.find(
 { $text: { $search: "Good" } },
 { score: { $meta: "textScore" }, customer: 1 }
).sort({ customer: 1, score: { $meta: "textScore" } });
```

10. **Q: Only show the rank**

```
db.orders.find(
 { $text: { $search: "Average" } },
 { score: { $meta: "textScore" }, _id: 0 }
);
```

============================================================

# **5) `$` POSITIONAL PROJECTION**

============================================================

---

## **THEORY (BULLET POINTS)**

* Returns the array element that matched the query.
* Works only when condition matches inside array.

---

## **PROPERTIES**

* Returns first matching element.
* Used only in projection.
* Requires `"array.field"` in query.

---

## **SYNTAX**

```
db.collection.find(
  { "array.field": condition },
  { "array.$": 1 }
)
```

---

## **10 EXAMPLES WITH QUESTIONS**

1. **Q: Show the array element where product='book'**

```
db.orders.find({ "items.product": "book" }, { "items.$": 1 });
```

2. **Q: Show item where price>100**

```
db.orders.find({ "items.price": { $gt: 100 } }, { "items.$": 1 });
```

3. **Q: Show item where qty>=10**

```
db.orders.find({ "items.qty": { $gte: 10 } }, { "items.$": 1 });
```

4. **Q: Show review where rating=5**

```
db.orders.find({ "reviews.rating": 5 }, { "reviews.$": 1 });
```

5. **Q: Show status where status='packed'**

```
db.orders.find({ "statusLogs.status": "packed" }, { "statusLogs.$": 1 });
```

6. **Q: Show element for product='bag'**

```
db.orders.find({ "items.product": "bag" }, { "items.$": 1 });
```

7. **Q: Show review rating<4**

```
db.orders.find({ "reviews.rating": { $lt: 4 } }, { "reviews.$": 1 });
```

8. **Q: Show item with price>=500**

```
db.orders.find({ "items.price": { $gte: 500 } }, { "items.$": 1 });
```

9. **Q: Show review rating 3 to 5**

```
db.orders.find({ "reviews.rating": { $gte: 3 } }, { "reviews.$": 1 });
```

10. **Q: Show delivered status**

```
db.orders.find({ "statusLogs.status": "delivered" }, { "statusLogs.$": 1 });
```

============================================================

# **6) `$` OPERATOR INSIDE ARRAY UPDATE**

============================================================

---

## **THEORY (BULLET POINTS)**

* Updates the **first matched array element**.
* Works only in update commands.

---

## **PROPERTIES**

* Only updates first matching element.
* Requires array filter in query.
* Works with `$set`, `$inc`, `$mul`, etc.

---

## **SYNTAX**

```
db.collection.updateOne(
  { "array.field": condition },
  { $set: { "array.$.field": value } }
)
```

---

## **10 EXAMPLES WITH QUESTIONS**

1. **Q: Change price of 'book' to 250**

```
db.orders.updateOne(
  { "items.product": "book" },
  { $set: { "items.$.price": 250 } }
);
```

2. **Q: Change rating 5 → 4**

```
db.orders.updateOne(
  { "reviews.rating": 5 },
  { $set: { "reviews.$.rating": 4 } }
);
```

3. **Q: Increase qty=10 → 11**

```
db.orders.updateOne(
  { "items.qty": 10 },
  { $set: { "items.$.qty": 11 } }
);
```

4. **Q: Update comment of rating=3**

```
db.orders.updateOne(
  { "reviews.rating": 3 },
  { $set: { "reviews.$.comment": "Updated" } }
);
```

5. **Q: Change 'packed' → 'done packing'**

```
db.orders.updateOne(
  { "statusLogs.status": "packed" },
  { $set: { "statusLogs.$.status": "done packing" } }
);
```

6. **Q: Set price>500 → 650**

```
db.orders.updateOne(
  { "items.price": { $gt: 500 } },
  { $set: { "items.$.price": 650 } }
);
```

7. **Q: Set rating >=3 to 10**

```
db.orders.updateOne(
  { "reviews.rating": { $gte: 3 } },
  { $set: { "reviews.$.rating": 10 } }
);
```

8. **Q: Update pencil qty to 25**

```
db.orders.updateOne(
  { "items.product": "pencil" },
  { $set: { "items.$.qty": 25 } }
);
```

9. **Q: shipped → out for delivery**

```
db.orders.updateOne(
  { "statusLogs.status": "shipped" },
  { $set: { "statusLogs.$.status": "out for delivery" } }
);
```

10. **Q: Update comment 'bad' → 'Improved'**

```
db.orders.updateOne(
  { "reviews.comment": "bad" },
  { $set: { "reviews.$.comment": "Improved" } }
);
```

============================================================

# **7) `$elemMatch` VS `$slice` (INTERVIEW SUMMARY)**

============================================================

* `$elemMatch` filters array by condition → returns **ONE matched element**.
* `$slice` returns **subset based on count** → NOT condition based.
* `$elemMatch` = conditional extraction.
* `$slice` = positional extraction.
* `$elemMatch` cannot return multiple elements.
* `$slice` cannot filter by values.
* Both preserve original array order.
* Cannot use both on same array field.

============================================================



============================================================

---

