APPLICATIONS, DATABASES, MIDDLEWARE & CLIENT-SERVER ARCHITECTURE
==================[TOPIC-1]============================

1. What is an Application?
==========================

Definition:
-----------
An application is a software system designed to perform a collection of related tasks for an end user or another program. 
It implements business logic, interacts with users or other systems, and produces value (information, services, automation).

Core Components:
----------------
- User Interface (UI): how humans interact (GUI, CLI, API).
- Business Logic / Domain Layer: rules, validations, workflows.
- Persistence Layer: storage of state and data.
- Integration Layer: communication with other systems (APIs, message buses).
- Infrastructure Layer: runtime environment (OS, containers, servers).

Behavior & Responsibilities:
-----------------------------
- Accept inputs (user, sensors, other apps).
- Validate and transform inputs according to business rules.
- Persist necessary state (save, update, delete).
- Produce outputs (UI response, files, events, notifications).
- Scale and maintain state under concurrent use.
- Enforce security, consistency, and reliability.

----------------------------------------------
2. Types of Applications
----------------------------------------------

A. By Deployment / Interface:
-----------------------------
1. Desktop Applications â€“ e.g., MS Word
   - Runs locally, rich UI, local persistence.
2. Web Applications â€“ e.g., Gmail, Amazon
   - Accessed via browser; uses HTTP/HTTPS.
3. Mobile Applications â€“ e.g., WhatsApp, Uber
   - Runs on Android/iOS; may sync data online.
4. CLI Applications â€“ e.g., Git, npm
   - Text-based interface.
5. Embedded/IoT Applications â€“ e.g., Smart sensors
   - Real-time, resource-constrained.

B. By Architecture:
-------------------
1. Monolithic: tightly coupled single deployment.
2. Microservices: small, independent services.
3. Serverless: event-driven, runs on demand.
4. Event-driven: reactive, async communication.

C. By Purpose:
--------------
- Transactional (Banking systems)
- Analytical (BI dashboards)
- Real-time (Chat, Streaming)
- Batch (ETL jobs)
- Content (CMS, YouTube)

----------------------------------------------
3. Why Applications Need Databases
----------------------------------------------
Applications require databases for persistent, consistent, and queryable data storage.

Reasons:
--------
1. Durability & Persistence â€“ data survives crashes.
2. Concurrency Control â€“ multiple users safely update data.
3. Querying & Indexing â€“ efficient searches and aggregations.
4. Data Integrity â€“ foreign keys, constraints.
5. Scalability â€“ optimized for reads/writes.
6. Security & Auditing â€“ roles, permissions, logs.
7. Recovery â€“ backups and rollback mechanisms.

When a DB may not be required:
------------------------------
- Simple scripts, static websites, or cache-only systems.

----------------------------------------------
4. Do All Databases Fit All Applications?
----------------------------------------------
No. Different databases suit different workloads.

Types of Databases:
-------------------
A. Relational Databases (RDBMS): PostgreSQL, MySQL, Oracle
   - Structured, schema-defined, supports SQL joins, ACID compliance.

B. Document Stores: MongoDB, Couchbase
   - JSON-like flexible schema, good for modern web apps.

C. Key-Value Stores: Redis, DynamoDB
   - Fast lookups, caching, session storage.

D. Column-Family Stores: Cassandra, HBase
   - Distributed, scalable for large datasets.

E. Graph Databases: Neo4j, Amazon Neptune
   - Relationship-heavy queries (social networks).

F. Time-Series Databases: InfluxDB, TimescaleDB
   - Optimized for timestamped data.

G. Search Engines: Elasticsearch, Solr
   - For text search and analytics.

----------------------------------------------
5. What is a Server / Middleware?
----------------------------------------------
Server:
-------
A process or machine providing services to clients (hosts applications, manages resources).

Middleware:
------------
Software layer between OS/network and applications â€” handles communication, authentication, routing, messaging, and transformations.

Roles of Middleware:
--------------------
- Request handling & routing
- Resource management (threads, memory)
- Security (auth, rate-limits)
- Logging, caching, load balancing
- Protocol translation

Types of Middleware:
--------------------
1. Web Servers: Apache, Nginx (serves static files, reverse proxy).
2. App Servers: Node.js, Tomcat (executes business logic).
3. API Gateways: Kong, AWS API Gateway (handles auth, routing).
4. Message Brokers: RabbitMQ, Kafka (asynchronous messaging).
5. Integration Middleware: MuleSoft, ESB (protocol transformation).
6. Caching Middleware: Redis, Memcached.
7. Database Middleware: Hibernate, Sequelize (ORM, pooling).
8. Auth Middleware: Keycloak, OAuth2 servers.
9. Monitoring Middleware: Prometheus, OpenTelemetry.

----------------------------------------------
6. Clientâ€“Server Architecture (Deep Dive)
----------------------------------------------

Definition:
-----------
Clientâ€“Server architecture separates responsibilities between clients (requesters) and servers (providers).

Flow Components:
----------------
- Client: browser/mobile app
- Web Server: Apache/Nginx
- Application Server: Node.js/Tomcat/Django
- Database Server: PostgreSQL/MongoDB
- Middleware: caching, API gateway, auth, message brokers
- CDN: static content delivery

Requestâ€“Response Life Cycle:
-----------------------------
1. User initiates a request (e.g., open https://example.com)
2. DNS resolves domain â†’ IP
3. Browser connects via TCP (HTTPS uses TLS)
4. HTTP request sent â†’ Web Server
5. Web Server proxies to App Server
6. App Server processes request (auth, validation, business logic)
7. App Server queries Database
8. DB returns data (SQL/NoSQL)
9. Response built (JSON/HTML)
10. Web Server returns response to Client
11. Browser renders result (UI updates)

Protocols:
----------
- DNS, TCP/IP, TLS, HTTP/HTTPS
- WebSockets, gRPC, Kafka (for inter-service)
- SQL/NoSQL driver protocols

Where Apache Fits:
------------------
- Acts as edge server
- Handles SSL/TLS, routing, static file delivery
- Proxies to backend app (Node, Tomcat)
- Integrates with CDN for caching

Database Role:
--------------
- Central data store (stateful)
- Accessed via ORM or query drivers
- Maintains ACID transactions or eventual consistency

----------------------------------------------
7. Inspecting Network in Browser
----------------------------------------------
Steps (Chrome DevTools):
1. Open DevTools (Ctrl+Shift+I)
2. Go to â€œNetworkâ€ tab
3. Reload page to capture requests
4. Inspect individual requests (headers, payload, response)
5. Check timing, cookies, caching
6. Replay or copy as cURL for debugging
7. Use throttling to simulate slow networks

Common Indicators:
------------------
- 304 = cached resource
- 401/403 = auth failure
- CORS errors = missing access headers
- High TTFB = slow backend or DB

----------------------------------------------
8. Common Design Considerations
----------------------------------------------
- CAP theorem trade-offs (Consistency, Availability, Partition)
- Normalize for integrity, denormalize for performance
- Sync vs Async communication
- Monolith vs Microservices decision
- Cache wisely (avoid stale data)
- Trace requests (observability)

----------------------------------------------
9. Summary
----------------------------------------------
Application: Implements UI + Logic + Data access for user value.
DB: Stores data persistently, ensures consistency and security.
Server/Middleware: Connects clients to logic and data securely.

Clientâ€“Server Flow:
Browser â†’ Web Server â†’ App Server â†’ Database â†’ Response â†’ Browser

Key Technologies:
React/Angular, Node.js, Java/Spring Boot, MySQL, MongoDB, Apache/Nginx, Redis, Kafka

----------------------------------------------
10. Quick Reference Table
----------------------------------------------
| Layer | Responsibility | Common Tech |
|--------|----------------|--------------|
| Presentation | UI & Interaction | HTML, CSS, JS, React |
| Application | Logic & Workflow | Node.js, Spring Boot, Django |
| Database | Persistent Storage | MySQL, PostgreSQL, MongoDB |
| Middleware | Routing, Auth, Caching | Nginx, Kafka, Redis |

=======================[TOPIC-2]=======================

ðŸ§­ OVERVIEW: What is a Tier (or Layer)?
---------------------------------------
A tier (or layer) is a logical or physical separation of concerns in an application.
Each tier focuses on a distinct responsibility:

1. Presentation Layer â†’ handles user interface and interaction.
2. Application / Business Logic Layer â†’ handles rules, decisions, workflows.
3. Database / Data Tier â†’ handles data storage, retrieval, and integrity.

Why this separation exists:
âœ… Maintainability â€“ Each layer can evolve independently.
âœ… Reusability â€“ Business logic can serve multiple interfaces (web, mobile, API).
âœ… Scalability â€“ Each layer can scale horizontally or vertically.
âœ… Security â€“ Restrict direct DB access; only logic layer mediates data flow.
âœ… Testability â€“ Easier unit testing of each concern.

------------------------------------------------------
ðŸ§± 1. PRESENTATION LAYER (User Interface Layer)
------------------------------------------------------
Definition:
-----------
The presentation layer is the front end â€” the interface through which users interact with the system.
It presents data to users and collects user inputs to send to the business layer.

Core Responsibilities:
----------------------
- Display data in a meaningful form (UI/UX)
- Validate user inputs (basic checks)
- Send requests to business logic (through APIs)
- Handle responses and show feedback/results
- Manage session, authentication tokens

Examples:
---------
| Type | Example Technologies | Description |
|------|----------------------|--------------|
| Web UI | HTML, CSS, JavaScript (React, Angular, Vue) | Browser-based interface |
| Mobile | Kotlin, Swift, Flutter | Native or hybrid mobile UI |
| Desktop | Electron, WPF, JavaFX | Local desktop apps |
| Command Line | Bash, PowerShell | Textual I/O UI |
| API Consumer | Postman, curl | Headless interface |

Behavior Flow Example:
----------------------
User adds an item â†’ Browser (React app) calls â†’ POST /api/cart/add

The UI only shows and collects data; business logic handles the actual operation.

------------------------------------------------------
âš™ï¸ 2. APPLICATION / BUSINESS LOGIC LAYER
------------------------------------------------------
Definition:
-----------
This is the brain of the system. It contains business rules, calculations, validations, and process orchestration.

Core Responsibilities:
----------------------
1. Process requests from the presentation layer.
2. Validate and authorize data.
3. Apply business rules (discounts, workflows, etc.).
4. Communicate with other services or APIs.
5. Interact with the database (through ORM or queries).
6. Manage transactions (commit/rollback).
7. Enforce security policies and logging.

Technologies:
-------------
- Node.js (Express, NestJS)
- Java (Spring Boot)
- Python (Django, Flask)
- .NET (C# ASP.NET)
- Middleware: API Gateways, Brokers, Auth servers

Typical Components:
-------------------
- Controllers / Routes
- Services (logic layer)
- Repositories / DAO (data access)
- Utilities (logging, error handling)

Behavior Flow Example:
----------------------
1. Request: POST /api/cart/add â†’ { "productId": 42, "quantity": 2 }
2. Controller calls CartService.addItem()
3. Service checks stock, applies discounts.
4. Repository updates DB.
5. Returns JSON â†’ { "message": "Item added successfully" }
6. UI shows confirmation.

------------------------------------------------------
ðŸ—„ï¸ 3. DATABASE TIER (Data Access / Persistence Layer)
------------------------------------------------------
Definition:
-----------
The database tier handles persistent storage â€” saving, updating, retrieving data securely and efficiently.

Core Responsibilities:
----------------------
- Store data durably
- Retrieve efficiently using indexes
- Maintain relationships and constraints
- Enforce ACID properties
- Backup & recovery
- Provide data security

Technologies:
-------------
| Category | Examples |
|-----------|-----------|
| RDBMS | MySQL, PostgreSQL, Oracle |
| NoSQL | MongoDB, Cassandra, Redis |
| ORM | Hibernate, Sequelize, Prisma, Mongoose |
| Query Languages | SQL, GraphQL, MongoQL |

Behavior Example:
-----------------
INSERT INTO cart_items (user_id, product_id, qty) VALUES (1, 42, 2);

------------------------------------------------------
ðŸ”— CONNECTION BETWEEN ALL THREE LAYERS
------------------------------------------------------
Conceptual Architecture:
------------------------
+--------------------------+
|   Presentation Layer     | â† UI (React, Angular)   |
+------------â–²-------------+
             |
             | HTTP / API Request (JSON)
             |
+------------â–¼-------------+
| Application Layer        | â† Business Logic        |
+------------â–²-------------+
             |
             | SQL / ORM Queries
             |
+------------â–¼-------------+
| Database Layer           | â† Persistent Storage    |
+--------------------------+

Flow Example:
-------------
1. User interacts â†’ sends request to API.
2. Application layer validates, processes, queries DB.
3. Database returns result to Application layer.
4. Application prepares response â†’ sends to Presentation layer.
5. UI renders result.

------------------------------------------------------
ðŸ”’ COMMUNICATION & PROTOCOLS
------------------------------------------------------
| From | To | Protocol | Example |
|------|----|-----------|----------|
| Presentation â†’ Application | HTTP/HTTPS | fetch('/api/products') |
| Application â†’ Database | TCP, JDBC, Mongo protocol | SQL queries |
| Application â†” Services | gRPC, Message Queues | Kafka, RabbitMQ |

------------------------------------------------------
ðŸ’¡ ANALOGY
------------------------------------------------------
Restaurant Analogy:
- Presentation Layer â†’ Waiter (takes orders)
- Application Layer â†’ Kitchen (cooks based on rules)
- Database Layer â†’ Storage (ingredients)

Each layer has clear responsibility and boundaries.

------------------------------------------------------
ðŸ§© COMMON MISTAKES
------------------------------------------------------
| Mistake | Why Itâ€™s Bad | Fix |
|----------|--------------|-----|
| UI accesses DB directly | Security risk | Always go through Business layer |
| Business logic in UI | Hard to maintain | Keep logic in backend |
| Too many DB calls | Performance issue | Batch or cache queries |
| No validation in backend | Data corruption risk | Validate at all layers |
| Tight coupling | Hard to update | Use APIs and interfaces |

------------------------------------------------------
ðŸ§¾ SUMMARY TABLE
------------------------------------------------------
| Layer | Responsibility | Typical Tech | Communication |
|--------|----------------|---------------|----------------|
| Presentation | UI, User Interaction | React, HTML, CSS, JS | HTTP/HTTPS |
| Application | Logic, Validation, Rules | Node.js, Java, Django | ORM/DB Driver |
| Database | Persistent Storage | MySQL, MongoDB | SQL/NoSQL |

------------------------------------------------------
ðŸ” HUMAN SUMMARY
------------------------------------------------------
Presentation â†’ collects and displays data.
Application â†’ processes and applies logic.
Database â†’ stores data persistently.

Together they form a scalable, maintainable, and secure 3-tier architecture â€”
the standard for all modern applications.

==============================================
===================[TOPIC-3]=================================

ðŸ§  1ï¸âƒ£ What is a Database (DB)?
----------------------------------------------------
Definition:
A Database (DB) is a structured and organized collection of data stored electronically,
which allows efficient retrieval, insertion, updating, and deletion of data.

In simpler terms:
A Database = an organized digital filing system that lets software store and retrieve data efficiently.

Core Characteristics:
----------------------------------------------------
| Feature | Description |
|----------|--------------|
| Structured Storage | Data stored in organized format (tables, collections, key-value pairs). |
| Persistent | Data remains after power-off (non-volatile). |
| Queryable | Supports queries (SQL or NoSQL syntax). |
| Concurrent | Multiple users/processes can access simultaneously. |
| Secure | Access control, authentication, encryption supported. |

Common Uses of Databases:
----------------------------------------------------
1. Persistent storage for user accounts, payments, logs, etc.
2. Data retrieval and analytics (dashboards, reports).
3. Transactions (banking, ecommerce checkout).
4. Backup and recovery.
5. Integration between multiple systems.
6. Scalability for millions of users.

Example:
A shopping websiteâ€™s DB may include tables like:
- users
- products
- orders
- payments

Drawbacks / Challenges of Databases:
----------------------------------------------------
| Drawback | Explanation |
|-----------|--------------|
| Complex setup | Requires configuration and maintenance. |
| Performance bottlenecks | Poor query design can slow performance. |
| Scalability issues (RDBMS) | Hard to scale horizontally. |
| Cost | Commercial DB licenses are expensive. |
| Security risks | Improper configuration can lead to breaches. |
| Backup complexity | Managing huge backups is difficult. |
| Vendor lock-in | Hard to switch vendors due to proprietary schemas. |

====================================================
ðŸ§© 2ï¸âƒ£ Storing Data in Presentation Layer (Front-End)
====================================================
Sometimes, small temporary data (like 5MB) needs to be stored on the client/browser for:
- Form validation
- Offline caching
- Session persistence
- Quick reads (avoid DB call)

Client-side Storage Options:
----------------------------------------------------
| Method | Storage Limit | Persistent? | Example Use |
|---------|----------------|-------------|--------------|
| localStorage | ~5MB | Persistent | Save user settings, tokens |
| sessionStorage | ~5MB | Temporary | Form data, sessions |
| Cookies | ~4KB | Optional | Auth tokens, flags |
| IndexedDB | 50MB+ | Persistent | Offline web apps |

Example (Browser Console):
----------------------------------------------------
Step 1ï¸âƒ£: Store data
window.localStorage.setItem("userName", "Navin");
window.localStorage.setItem("userScore", "95");

Step 2ï¸âƒ£: Retrieve data
let name = window.localStorage.getItem("userName");
console.log(name); // Output: Navin

Step 3ï¸âƒ£: View stored data
- Open Chrome DevTools â†’ Application â†’ Local Storage
- Example:
  userName : Navin
  userScore : 95

Step 4ï¸âƒ£: Delete data
window.localStorage.removeItem("userName");
window.localStorage.clear(); // clears all

Use-case: Validation Example
----------------------------------------------------
localStorage.setItem("tempEmail", "user@example.com");
let email = localStorage.getItem("tempEmail");
if (!email.includes("@")) alert("Invalid Email");

Note: localStorage is useful for front-end validation or offline storage.
Avoid storing passwords or sensitive information.

====================================================
ðŸ§® 3ï¸âƒ£ What is NoSQL (with MongoDB focus)
====================================================
Definition:
NoSQL = "Not Only SQL" â€” non-relational databases designed for:
- Unstructured/semi-structured data
- Horizontal scalability
- Schema flexibility

Types of NoSQL Databases:
----------------------------------------------------
| Type | Description | Examples |
|-------|--------------|-----------|
| Document Store | JSON-like documents | MongoDB, CouchDB |
| Key-Value Store | Key-value pairs | Redis, DynamoDB |
| Column-Family Store | Column-based data | Cassandra, HBase |
| Graph Database | Node-edge relationships | Neo4j, OrientDB |

====================================================
ðŸŒ¿ MongoDB Deep Dive
====================================================
Definition:
MongoDB is a document-oriented NoSQL database storing data as BSON (Binary JSON).

Core Concepts:
----------------------------------------------------
| Term | Meaning |
|-------|----------|
| Database | Group of collections |
| Collection | Like a table (group of documents) |
| Document | JSON/BSON record |
| Field | Key-value pair |
| _id | Unique identifier |

Example Document:
----------------------------------------------------
{
  "_id": 1,
  "name": "Navin",
  "course": "AI",
  "marks": [85, 90, 92],
  "address": { "city": "Chennai", "pin": 600001 }
}

Basic MongoDB Commands:
----------------------------------------------------
# Show all databases
show dbs

# Create/use a database
use studentDB

# Insert data
db.students.insertOne({ name: "Navin", course: "AI", score: 95 });

# Retrieve data
db.students.find();

# Query specific records
db.students.find({ score: { $gt: 90 } });

# Update document
db.students.updateOne({ name: "Navin" }, { $set: { score: 98 } });

# Delete document
db.students.deleteOne({ name: "Navin" });

Features of MongoDB:
----------------------------------------------------
- Schema-less (flexible structure)
- Horizontal scaling (sharding, replication)
- High availability (replica sets)
- Rich query language and aggregation
- Integration with Node.js, Python, Java
- Indexing for fast search

When to Use MongoDB:
----------------------------------------------------
- Dynamic or evolving schema
- JSON-based applications (Node.js, React)
- High read/write workloads
- Real-time analytics and IoT

Limitations of MongoDB:
----------------------------------------------------
| Limitation | Explanation |
|-------------|--------------|
| No strict schema | May cause inconsistent data |
| Weak ACID | Eventual consistency possible |
| Limited joins | Requires aggregation pipelines |
| Query complexity | Different from SQL |
| Data duplication | Denormalization can lead to redundancy |

====================================================
âš–ï¸ 4ï¸âƒ£ SQL vs NoSQL â€” Full Comparison
====================================================
| Feature | SQL (RDBMS) | NoSQL (MongoDB) |
|----------|--------------|----------------|
| Data Model | Relational (tables) | Non-relational (documents, key-value) |
| Schema | Fixed | Dynamic / Schema-less |
| Transactions | Strong ACID | BASE (Eventual consistency) |
| Query Language | SQL | JSON-like syntax |
| Scalability | Vertical | Horizontal |
| Relationships | Supports joins | Embedded/referenced docs |
| Flexibility | Rigid | Highly flexible |
| Performance | Slower at huge scale | Faster for large datasets |
| Use Cases | Banking, ERP, Finance | Social media, IoT, Big Data |
| Examples | MySQL, Oracle, PostgreSQL | MongoDB, DynamoDB, Cassandra |

Scaling Comparison:
----------------------------------------------------
| Scaling Type | SQL (RDBMS) | NoSQL (MongoDB) |
|---------------|--------------|----------------|
| Vertical Scaling | Add CPU/RAM | Limited |
| Horizontal Scaling | Complex | Built-in sharding |
| Replication | Manual setup | Replica sets |
| Performance | Drops under heavy load | Stable at large scale |

Pros and Cons Summary:
----------------------------------------------------
| Type | Pros | Cons |
|-------|------|------|
| SQL | Strong consistency, relational power | Hard to scale, rigid schema |
| NoSQL | Flexible, high performance | Weak joins, eventual consistency |

====================================================
ðŸ§¾ SUMMARY SNAPSHOT
====================================================
| Topic | Key Idea |
|--------|-----------|
| DB Definition | Organized data system for efficient access |
| DB Uses | Persistence, analytics, backups, scalability |
| DB Drawbacks | Maintenance, scaling cost |
| Frontend Storage | localStorage (~5MB) for client validation |
| NoSQL | Schema-flexible, scalable databases |
| MongoDB | Document-based, JSON storage |
| SQL vs NoSQL | SQL = structured; NoSQL = scalable & flexible |

======================[TOPIC-4]================================

PART A â€” Types of NoSQL Databases vs SQL Databases
---------------------------------------------------

SQL (RDBMS)
- Model: Tables (rows/columns)
- Schema: Fixed
- Query Language: SQL
- Transactions: ACID
- Scaling: Vertical
- Use cases: Banking, ERP, financial systems

NO-SQL Types:
-------------
1. Document Store (e.g., MongoDB)
2. Key-Value Store (e.g., Redis)
3. Column-Family Store (e.g., Cassandra)
4. Graph Store (e.g., Neo4j)

Key Differences Summary Table
-----------------------------
| Concern | SQL | Document | Key-Value | Column-Family | Graph |
|----------|-----|-----------|-----------|----------------|--------|
| Schema | Rigid | Flexible | None | Flexible | Flexible |
| Joins | Native | Limited | None | None | Native |
| Transactions | Strong ACID | Tunable | Limited | Tunable | ACID |
| Best For | Relational Data | JSON docs | Caches | Big Data | Relationships |
| Scaling | Vertical | Horizontal | Horizontal | Horizontal | Varies |

=============================================================
PART B â€” FULL DEMONSTRATION: MongoDB & Firebase
=============================================================

Scenarios:
1. User Registration + Email Verification
2. Password Reset
3. Role-Based Access (RBAC)

-------------------------------------------
MongoDB Demo (Node.js + Express + Mongoose)
-------------------------------------------

PROJECT STRUCTURE:
project/
  â”œâ”€ .env
  â”œâ”€ server.js
  â”œâ”€ models/User.js
  â”œâ”€ routes/auth.js
  â”œâ”€ controllers/authController.js
  â”œâ”€ middleware/validate.js
  â””â”€ utils/email.js

Mongoose Schema:
----------------
const userSchema = new mongoose.Schema({
  email: String,
  passwordHash: String,
  isVerified: Boolean,
  roles: [String],
  createdAt: Date
});

Business Flow:
1. Register User -> Hash Password -> Save
2. Send Email Verification Token
3. Verify Email Token -> Activate Account
4. Login -> JWT Access + Refresh Tokens
5. Validate Role Access -> Middleware Check

Security Best Practices:
------------------------
- Hash passwords (bcrypt)
- Validate data (Joi)
- Use HTTPS
- Use short-lived access tokens
- Rotate refresh tokens
- Least privilege DB access

Common Mistakes:
----------------
- Plaintext passwords
- No server-side validation
- Unrestricted CORS
- Leaking tokens in client storage
- Missing indexes

--------------------------------------------------
Firebase Demo (Firebase Auth + Firestore)
--------------------------------------------------

Setup:
- Enable Email/Password Auth
- Create Firestore DB
- Use Firebase SDK

Client Example (Registration):
------------------------------
const { user } = await auth.createUserWithEmailAndPassword(email, password);
await user.sendEmailVerification();
await db.collection("users").doc(user.uid).set({
  email: user.email,
  createdAt: firebase.firestore.FieldValue.serverTimestamp(),
  roles: ["user"]
});

Login Flow:
------------
const { user } = await auth.signInWithEmailAndPassword(email, password);
if (!user.emailVerified) throw new Error("Email not verified");
const idToken = await user.getIdToken();

Server Verification (Node.js Admin SDK):
---------------------------------------
const decoded = await admin.auth().verifyIdToken(idToken);

Password Reset (Client):
------------------------
await auth.sendPasswordResetEmail(email);

RBAC via Custom Claims:
-----------------------
await admin.auth().setCustomUserClaims(uid, { admin: true });

----------------------------------------------
Validation, Terms & Common Mistakes
----------------------------------------------
Frontend Validation: Check email format, password strength.
Backend Validation: Required fields, SQL/NoSQL injection prevention.

Common Mistakes:
1. Trusting only frontend validation
2. Storing secrets in client
3. No HTTPS
4. Weak password policy
5. Missing rate-limiting
6. Not rotating refresh tokens
7. Not sanitizing DB queries
8. No audit logging

------------------------------------------------
FINAL COMPARISON: MongoDB vs Firebase
------------------------------------------------
MongoDB:
- Full control, custom logic
- Complex setup, manual email flow
- Requires server and security setup

Firebase:
- Managed service, built-in auth/email
- Quick to implement
- Vendor lock-in

------------------------------------------------
CHECKLIST FOR SECURE AUTH SYSTEM
------------------------------------------------
1. HTTPS / TLS
2. Strong password rules
3. Rate limit login endpoints
4. Hash & salt passwords
5. Use short-lived access tokens
6. Securely store refresh tokens
7. Keep secrets out of client
8. Use indexes on emails
9. Sanitize all inputs
10. Monitor logs

============================================================
END OF GUIDE
============================================================
